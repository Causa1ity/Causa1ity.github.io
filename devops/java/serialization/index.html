<!doctype html><html lang=zh>
<head><meta http-equiv=content-type content="text/html" charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href="/css/main.min.603bdac5a514a018c8a598608c9559e9356dee22c6203eb4ba7ad06c438010c7.css" integrity="sha256-YDvaxaUUoBjIpZhgjJVZ6TVt7iLGID60unrQbEOAEMc=">
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Lora&display=swap" rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css>
<script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/code-line></script><title>Java 序列化</title>
</head>
<body class="flex flex-col bg-gray-100">
<div class="flex my-8 font-serif">
<div class="flex-auto w-1/3">
<div class="w-64 h-full mr-2 ml-auto">
<div class=mb-8><div class="border rounded-lg shadow-md">
<div class="h-32 flex rounded-t-lg text-white" style=background-image:url(/images/background-1.jpg)>
<div class=m-auto>
<div class="text-center font-serif text-3xl my-2"><a href=/>Noth</a></div>
<div class="text-center font-serif">去码头整点薯条</div>
</div>
</div>
<nav class="rounded-b-lg bg-white">
<ul class="py-2 ml-8">
<li class="my-2 content-center">
<a href=/ class=hover:text-red-300><i class="fas fa-home"></i>&nbsp;&nbsp;&nbsp;主页</a>
</li>
<li class="my-2 content-center">
<a href=/metapages/archive/ class=hover:text-red-300><i class="fas fa-scroll"></i>&nbsp;&nbsp;归档</a>
</li>
<li class="my-2 content-center">
<a href=/categories/ class=hover:text-red-300><i class="fas fa-th"></i>&nbsp;&nbsp;&nbsp;分类</a>
</li>
<li class="my-2 content-center">
<a href=/tags/ class=hover:text-red-300><i class="fas fa-tags"></i>&nbsp;&nbsp;标签</a>
</li>
<li class="my-2 content-center">
<a href=/metapages/link/ class=hover:text-red-300><i class="fas fa-link"></i>&nbsp;&nbsp;&nbsp;链接</a>
</li>
<li class="my-2 content-center">
<a href=/metapages/message/ class=hover:text-red-300><i class="fas fa-comment-alt"></i>&nbsp;&nbsp;&nbsp;留言</a>
</li>
</ul>
</nav>
</div></div>
<div class="sticky top-2">
<div class=toc>
<nav id=TableOfContents>
<ul>
<li><a href=#浅尝>浅尝</a>
<ul>
<li><a href=#序列化与反序列化>序列化与反序列化</a></li>
</ul>
</li>
<li><a href=#登堂>登堂</a>
<ul>
<li><a href=#对象序列化过程跟踪>对象序列化过程跟踪</a>
<ul>
<li><a href=#constructor>Constructor</a></li>
<li><a href=#writeobject>writeObject</a></li>
<li><a href=#wroteclassdesc>wroteClassDesc</a></li>
<li><a href=#writeserialdata>writeSerialData</a></li>
</ul>
</li>
<li><a href=#流程总结>流程总结</a></li>
<li><a href=#遗留问题>遗留问题</a></li>
<li><a href=#对象反序列化过程跟踪>对象反序列化过程跟踪</a></li>
<li><a href=#中间类>中间类</a>
<ul>
<li><a href=#handletable>HandleTable</a></li>
<li><a href=#replacetable>ReplaceTable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</div>
</div>
</div>
<div class="flex-auto w-2/3">
<div class="w-200 border rounded-lg bg-white ml-2 mr-auto px-4">
<h1 class="font-serif text-4xl text-center mt-8 mb-2">Java 序列化</h1>
<div class="text-right text-gray-500 mr-20">
<span>
Apr. 12, 2021 |
<i class="far fa-bookmark"></i>
</span>
</div>
<div class="content px-6 mb-8">
<h2 id=浅尝>浅尝</h2>
<h3 id=序列化与反序列化>序列化与反序列化</h3>
<p>为了能够将对象在通信过程中进行传送，Java提供了序列化机制。简单来说，Java序列化就是将Java对象转换成字节序列的过程，而反序列化就是将字节序列在转换会Java对象的过程。</p>
<p>一个Java对象想要能够进行序列化，必须包含<code>java.io.Serialization</code>接口，其定义如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Serializable</span> <span style=color:#f92672>{}</span>
</code></pre></div><p><code>Serializable</code>接口没有提供任何方法，也就是说这是一个空接口。</p>
<p>对于已经提供了接口的对象，可以使用ObjectOutputStream()将其进行序列化；ObjetcInputStream()则可以对其进行反序列化。</p>
<p>接下来实验一下序列化和反序列化的使用。首先创建一个实现了Serializable接口的类，这里先简单的创建一个只有一个int id和一个String data两个字段的类：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoClass</span> <span style=color:#66d9ef>implements</span> Serializable <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> id<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> String data<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DemoClass</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> id<span style=color:#f92672>,</span> String data<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> id<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> data<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>测试序列化和反序列化的代码如下，首先创建一个DemoClass的对象，然后对其进行序列化和反序列化操作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ClassNotFoundException <span style=color:#f92672>{</span>
        DemoClass dc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DemoClass<span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;aSimpleClass&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>dc<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>

        <span style=color:#75715e>// 序列化一个对象并保存到一个字节数组中
</span><span style=color:#75715e></span>        ByteArrayOutputStream bytesOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream<span style=color:#f92672>();</span>
        ObjectOutputStream out <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream<span style=color:#f92672>(</span>bytesOut<span style=color:#f92672>);</span>
        out<span style=color:#f92672>.</span><span style=color:#a6e22e>writeObject</span><span style=color:#f92672>(</span>dc<span style=color:#f92672>);</span>
        out<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> bytesOut<span style=color:#f92672>.</span><span style=color:#a6e22e>toByteArray</span><span style=color:#f92672>();</span>

        <span style=color:#75715e>// 从一个字节数组中读取一个对象
</span><span style=color:#75715e></span>        ByteArrayInputStream bytesIn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream<span style=color:#f92672>(</span>bytes<span style=color:#f92672>);</span>
        ObjectInputStream in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream<span style=color:#f92672>(</span>bytesIn<span style=color:#f92672>);</span>
        DemoClass ddc <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>DemoClass<span style=color:#f92672>)</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readObject</span><span style=color:#f92672>();</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>ddc<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>其输出应改与下面类似：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>top<span style=color:#f92672>.</span><span style=color:#a6e22e>causality</span><span style=color:#f92672>.</span><span style=color:#a6e22e>learnjava</span><span style=color:#f92672>.</span><span style=color:#a6e22e>DemoClass</span><span style=color:#a6e22e>@12a3a380</span>
top<span style=color:#f92672>.</span><span style=color:#a6e22e>causality</span><span style=color:#f92672>.</span><span style=color:#a6e22e>learnjava</span><span style=color:#f92672>.</span><span style=color:#a6e22e>DemoClass</span><span style=color:#a6e22e>@2f4d3709</span>
</code></pre></div><p>此外，序列化后的对象也可以直接输出到文件中，下面这个测试程序同样是创建了一个简单的DemoClass对象，然后将其序列化后保存到文件中，之后再从文件中读取到ddc中。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ClassNotFoundException <span style=color:#f92672>{</span>
        DemoClass dc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DemoClass<span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;aSimpleClass&#34;</span><span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>dc<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>

        <span style=color:#75715e>// 序列化一个对象并保存到一个文件中
</span><span style=color:#75715e></span>        FileOutputStream fileOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileOutputStream<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;./dc.ser&#34;</span><span style=color:#f92672>);</span>
        ObjectOutputStream out <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream<span style=color:#f92672>(</span>fileOut<span style=color:#f92672>);</span>
        out<span style=color:#f92672>.</span><span style=color:#a6e22e>writeObject</span><span style=color:#f92672>(</span>dc<span style=color:#f92672>);</span>
        out<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
        fileOut<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>

        <span style=color:#75715e>// 从一个文件中读取一个对象
</span><span style=color:#75715e></span>        FileInputStream fileIn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;./dc.ser&#34;</span><span style=color:#f92672>);</span>
        ObjectInputStream in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream<span style=color:#f92672>(</span>fileIn<span style=color:#f92672>);</span>
        DemoClass ddc <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>DemoClass<span style=color:#f92672>)</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>readObject</span><span style=color:#f92672>();</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>ddc<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>程序与前面的几乎完全一样，只是将字节IO流更换成了文件IO流，此时序列化后的对象就被存储到了当前项目下的<strong>dc.ser</strong>文件中，由于是字节型的数据流，因此可以使用二进制阅读器打开：</p>
<p><img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414150303423.png alt=image-20210414150303423></p>
<p>虽然还不能确切的完全理解，但是可以看出类其中包含很多有关我们创建的对象的关键信息。</p>
<h2 id=登堂>登堂</h2>
<h3 id=对象序列化过程跟踪>对象序列化过程跟踪</h3>
<p>这里使用前面的输出到字节数组中的例子作为程序，从创建ObjectOutputStream开始跟踪，所以首先在创建out出下一个断点：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414150613842.png alt=image-20210414150613842></p>
<h4 id=constructor>Constructor</h4>
<p>跟踪进入构造函数内部：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414150822717.png alt=image-20210414150822717></p>
<p>在调用构造函数之前，会首先进行一个实力域的初始化：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> protocol <span style=color:#f92672>=</span> PROTOCOL_VERSION_2<span style=color:#f92672>;</span>
</code></pre></div><p>这里设置了一个协议版本，其值在ObjectStreamConstants接口中进行了定义，PROTOCOL_VERSION_2的值即为2，这个变量之后会用到，现在先继续向下跟踪。</p>
<p>初步分析，构造函数会首先运行一个verifySubclass()方法，这是一个验证安全性的函数，暂且按下不表；之后会创建三个对象：bout、handles、subs，首先了解以下这三个对象的类：</p>
<ul>
<li>
<p>BlockDataOutputStream:<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414152900466.png alt=image-20210414152900466></p>
<p>也就是说，这是一个具有两种工作模式的输出流，一种和DataOutputStream相同，也就是二进制输出流；另一种则是输出有数据块标记的数据。</p>
</li>
<li>
<p>HandleTable：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414153453981.png alt=image-20210414153453981></p>
<p>一个轻量级的hash表，他会按照升序将对象映射到一个整数型的handle；</p>
</li>
<li>
<p>ReplaceTable：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414153714381.png alt=image-20210414153714381></p>
<p>也是一个轻量级的hash表，这个表可以将对象映射到一个可替换的对象。</p>
</li>
</ul>
<p>暂时还不能完全清楚这三个对象的作用，但是考虑到bout是一个输出流并且接受out作为参数，可以推断bout是存储序列化对象值的字段，而其余两个hash表则有可能是用于寻找已经序列化的对象。</p>
<p>接下来是设置<code>enableOverride = false;</code>，根据变量定义，如果这个值设置为true，则写入对象时会使用writeObjectOverride()来替换writeObject()；</p>
<p>继续往下有一个writeStreamHeader()方法，根据名称也可以猜测这个方法会向输出流中写入一些东西，跟踪进去：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414154816597.png alt=image-20210414154816597></p>
<p>发现这里是调用一个bout.writeShort()方法；前面说了，bout有两种模式，默认情况下与DataOutputStream的工作方法相同，这里也是调用了一个writeShort()方法，也就是写入一个Short整数值；</p>
<blockquote>
<p>OutputStream抽象类是表示输出字节流的所有类的超类，这个类对象可以接受字节或字节数组并将其输出；</p>
<p>FilterOutputStream类是所有过滤输出流的超类，其本身只是简单的使用将所有请求传递给底层输出流的方式覆写了OutputStream类的所有方法；</p>
<p>DataOutputStream类则可以将原始的Java数据以与机器无关的方式写入到输出流中，也就是以字节形式输出</p>
<p>BlockDataOutputStream：这个类是OutputStream的子类，提供以两种方式输出流，一种是与DataOutputStream相同，另一种是“block data”模式输出由数据块数据标记括起来的数据。</p>
</blockquote>
<p>查看这两个字段值可以知道这是两个在ObjectStreamConstants的常量：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414155445593.png alt=image-20210414155445593></p>
<p>所以这个方法向bout中写入了两个数据，分别为：<code>final static short STREAM_MAGIC = (short)0xaced;</code>和<code>final static short STREAM_VERSION = 5;</code>。也就是说，使用这个构造函数创建ObjectOutputStream时会固定写入Header四个字节的值：<code>0xACED0005</code>；此时可以回头看一眼我们一开始序列化输出的文件，文件开头的4个字节正是：0xACED和0x0005。</p>
<p>这个方法之后执行了bout.setBlockDataMode(true)，也就是设置输出模式为块数据；这个方法会设置out的mode，同时返回之前的mode；如果设置后的mode与设置前的mode不同，则还会将缓冲区的数据写入到输出流中。所以说，在这一步完成后，会将数据写入到bytesOut中。</p>
<h4 id=writeobject>writeObject</h4>
<p>前面只是创建了对象，接下来开始将dc序列化并写入到字节输出流中。</p>
<p>接下来执行out.wirteObject(dc)方法，同样跟踪进去：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414161001429.png alt=image-20210414161001429></p>
<p>首先检查enableOverride，为true的话会执行writeObjectOverride()方法，在前面的初始化中此值被设置为false，所以将会继续向下执行writeObject0(obj, false)方法，这个方法比较长，其主要结构为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeObject0</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> unshared<span style=color:#f92672>)</span>
        <span style=color:#66d9ef>throws</span> IOException
    <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>boolean</span> oldMode <span style=color:#f92672>=</span> bout<span style=color:#f92672>.</span><span style=color:#a6e22e>setBlockDataMode</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
        depth<span style=color:#f92672>++;</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#f92672>...</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
            depth<span style=color:#f92672>--;</span>
            bout<span style=color:#f92672>.</span><span style=color:#a6e22e>setBlockDataMode</span><span style=color:#f92672>(</span>oldMode<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>try块内的内容为序列化的主要执行操作，我们首先来查看try块之外的内容。</p>
<p>首先是一个boolean oldMode = bout.setBlockDataMode(false)方法，这个方法设置BlockDataMode并返回之前的mode，因此这里是设置bout的mode为false并将之前的mode保存到oldMode中；也就是说，现在又将bout设置为DataOutputStream模式。</p>
<p>接下来将depth加一，depth表示递归的深度，目的是当对象引用了其他对象时，递归的将其也进行序列化。</p>
<p>而try块之后的内容这时就很明显了，depth减一来返回上一层；bout也恢复为之前的mode，当然也可以猜测是在这里将缓冲区写入到字节输出流中。</p>
<p>接下来看看try块内部的内容，其也可以分成几部分来分析：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>			<span style=color:#75715e>// handle previously written and non-replaceable objects
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> h<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>obj <span style=color:#f92672>=</span> subs<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>))</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeNull<span style=color:#f92672>();</span>
                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>unshared <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>=</span> handles<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>))</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeHandle<span style=color:#f92672>(</span>h<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> Class<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeClass<span style=color:#f92672>((</span>Class<span style=color:#f92672>)</span> obj<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> ObjectStreamClass<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeClassDesc<span style=color:#f92672>((</span>ObjectStreamClass<span style=color:#f92672>)</span> obj<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
</code></pre></div><p>这一块内容全是判断，目的是查看对象是否已经被序列化或是可以被替换，简单来看一下：首先是subs.lookup(obj)，也就是检查是否存在可以替换的对象；其次是handles.lookup，这是检查是否之前已经反序列化过；之后是检查是否是Class或者ObjectStreamClass，这两种情况下调用其他的方法，暂时；现在的类不符合以上任何一种情况，暂时先不考虑这些其他情况。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>			<span style=color:#75715e>// check for replacement object
</span><span style=color:#75715e></span>            Object orig <span style=color:#f92672>=</span> obj<span style=color:#f92672>;</span>
            Class<span style=color:#f92672>&lt;?&gt;</span> cl <span style=color:#f92672>=</span> obj<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>();</span>
            ObjectStreamClass desc<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// REMIND: skip this check for strings/arrays?
</span><span style=color:#75715e></span>                Class<span style=color:#f92672>&lt;?&gt;</span> repCl<span style=color:#f92672>;</span>
                desc <span style=color:#f92672>=</span> ObjectStreamClass<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>cl<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>desc<span style=color:#f92672>.</span><span style=color:#a6e22e>hasWriteReplaceMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>||</span>
                    <span style=color:#f92672>(</span>obj <span style=color:#f92672>=</span> desc<span style=color:#f92672>.</span><span style=color:#a6e22e>invokeWriteReplace</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>))</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
                    <span style=color:#f92672>(</span>repCl <span style=color:#f92672>=</span> obj<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>())</span> <span style=color:#f92672>==</span> cl<span style=color:#f92672>)</span>
                <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
                cl <span style=color:#f92672>=</span> repCl<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>enableReplace<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                Object rep <span style=color:#f92672>=</span> replaceObject<span style=color:#f92672>(</span>obj<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>rep <span style=color:#f92672>!=</span> obj <span style=color:#f92672>&amp;&amp;</span> rep <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    cl <span style=color:#f92672>=</span> rep<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>();</span>
                    desc <span style=color:#f92672>=</span> ObjectStreamClass<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>cl<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
                obj <span style=color:#f92672>=</span> rep<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
</code></pre></div><blockquote>
<p>这里创建了两个特殊的对象：Class和ObjectStreamClass</p>
<p>Class是Java反射机制的重要对象，可以参考<a href=/devops/java/reflection/ title="Java 反射">Java反射</a></p>
<p>ObjectStreamClass则本身是已经序列化的类描述符，它包含了类的名称和serialVersionUID，在JVM中运行的某个类的ObjectStreamClass可以通过lookup方法来找到。</p>
<p>serialVersionUID是一个long行的整数，其表示流唯一标识符（Stream Unique Identifiers），暂时可以认为使用这个值可以唯一的标识一个类。</p>
</blockquote>
<p>我们可以稍微跟踪一个这个流程，首先是使用orig获取到obj的引用，然后获取到obj的类保存到cl中；接下来创建了一个类描述符desc。在循环中，又创建了一个Class，根据名称猜测是用来保存替换类的，继续往下使用desc获得cl的描述符，也就是说desc表示obj的类的描述符。接下来判断可以WriteReplace，可以即执行，否则跳出循环。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>			<span style=color:#75715e>// if object replaced, run through original checks a second time
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#f92672>!=</span> orig<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                subs<span style=color:#f92672>.</span><span style=color:#a6e22e>assign</span><span style=color:#f92672>(</span>orig<span style=color:#f92672>,</span> obj<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    writeNull<span style=color:#f92672>();</span>
                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>unshared <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>(</span>h <span style=color:#f92672>=</span> handles<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>))</span> <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    writeHandle<span style=color:#f92672>(</span>h<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> Class<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    writeClass<span style=color:#f92672>((</span>Class<span style=color:#f92672>)</span> obj<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> ObjectStreamClass<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    writeClassDesc<span style=color:#f92672>((</span>ObjectStreamClass<span style=color:#f92672>)</span> obj<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>

</code></pre></div><p>这里对如果在上一步中替换了的情况，在这种情况下再次执行一次判断一开始的判断。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>			<span style=color:#75715e>// remaining cases
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeString<span style=color:#f92672>((</span>String<span style=color:#f92672>)</span> obj<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cl<span style=color:#f92672>.</span><span style=color:#a6e22e>isArray</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                writeArray<span style=color:#f92672>(</span>obj<span style=color:#f92672>,</span> desc<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> Enum<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeEnum<span style=color:#f92672>((</span>Enum<span style=color:#f92672>&lt;?&gt;)</span> obj<span style=color:#f92672>,</span> desc<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>obj <span style=color:#66d9ef>instanceof</span> Serializable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                writeOrdinaryObject<span style=color:#f92672>(</span>obj<span style=color:#f92672>,</span> desc<span style=color:#f92672>,</span> unshared<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>extendedDebugInfo<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NotSerializableException<span style=color:#f92672>(</span>
                        cl<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n&#34;</span> <span style=color:#f92672>+</span> debugInfoStack<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>());</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NotSerializableException<span style=color:#f92672>(</span>cl<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
</code></pre></div><p>前面对可以进行快捷操作的对象进行处理，还剩下来的是没有经过序列化并且不能被替换的对象，在这里进行序列化操作：首先判断对象是否为String、Array或Enum，三者会调用专门的写入函数，对于实现了Serializable接口的对象，则会执行writeOrdinaryObject(obj, desc, unshared)方法，也就是说这个函数中将执行对一般对象序列化的具体操作，我们的程序表示从这里进入：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414172223083.png alt=image-20210414172223083></p>
<p>首先通过desc检查是否已经经过序列化，首先是调用了desc.checkSerialize()，这个方法会检查这个类是否允许序列化。</p>
<p>检查完成开始进行写入操作，首先是bout.writeByte(TC_OBJECT)，写入一个字节：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414172902635.png alt=image-20210414172902635></p>
<p>也就是说这个字节表名当前序列化的是一个表明是一个Object，也就是一般的类对象；</p>
<h4 id=wroteclassdesc>wroteClassDesc</h4>
<p>接下来执行writeClassDesc(desc, fase)方法写入类描述符：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414173015429.png alt=image-20210414173015429></p>
<p>对desc进行检查，根据情况执行方法，一般将会执行最后一项，跟踪进去：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414173135322.png alt=image-20210414173135322></p>
<p>首先写入一个字节：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414173224730.png alt=image-20210414173224730></p>
<p>表明这是一个新的类描述符。写入后会调用handle.assign()方法，当unshared为false的时候，会将描述符存入handles以供之后使用。</p>
<p>接下来检查协议版本，这里是VERSION_2，所以将会执行writeClassDescriptor(desc)，跟踪后会继续调用desc.writeNonProxy(this)：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414181416948.png alt=image-20210414181416948></p>
<p>进入这个方法之后会首先调用out.writeUTF(name)和out.writeLong(getSerialVersionUID())，而这两个方法实际上是调用bout.writeUTF()和bout.writeLong()方法；</p>
<blockquote>
<p>注意此处的out和bout，这里的out是参数变量，所以需要向上一级追溯。在writeClassDescriptor(desc)将desc作为参数传入其中，而这个方法又调用desc.writeNonProxy(this)：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414174458714.png alt=image-20210414174458714></p>
<p>也就是说，out是这里的this，也就是对象。</p>
<p>不断向上追溯，可以发现调用链为：out.writeObject(dc)->writeObject0(dc)->writeOrdinaryObject(dc, desc, unshared)->writeClassDesc(desc, false)->writeNonProxyDesc(desc, unshared)->writeClassDescriptor(desc)->desc.writeNonProxy(this)</p>
<p>在这个过程中，调用了out对象的writeObject()方法，然后由这个方法调用了自身的其他方法，直到desc.writeNonProxy(this)这个时候，仍然是out在调用方法，因此这个this表示的仍旧是out。</p>
<p>因此，这里的out就是引用我们创建的ObjectOutputStream对象。但是还需要注意，在这个方法调用之后会进入到一个新的对象（desc）中，此时环境发生了变化。</p>
</blockquote>
<p>调用bout.writeUTF()和bout.writeLong()方法，而之前又设置了bout的mode为false，也即使用DataOutputStream模式，因此这两个方法就是向缓冲区写入对应的内容。</p>
<blockquote>
<p>writeUTF()会将UTF-8字符串以二进制形式写入到输入流中，写入时会首先写入两个字节的表示实际写入的长度，在这两个字节之后，会按顺序输出字符串的每个字符。</p>
</blockquote>
<p>这里bout.writeUTF(name)，现在的环境是在desc对象中，所以这里的name是desc.name，而desc是我们dc对象的类的类描述符，所以这里会name等于dc的类的名称，即：name=<strong>top.causality.learnjava.DemoClass</strong>，因此这里writeUTF(name)将会依次写入0x0033和<strong>top.causality.learnjava.DemoClass</strong>的二进制表示。</p>
<p>接下来的bout.writeLong()则是同样的道理，getSerialVersionUID()会获取到DemoClass的唯一类描述符，然后写入到缓冲区。</p>
<p>继续向下执行：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414181505833.png alt=image-20210414181505833></p>
<p>创建了一个byte的变量flags，可以看出是根据类的一些特征写入标志位。</p>
<p>继续向下：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414181720281.png alt=image-20210414181720281></p>
<p>首先写入两个字节fields.lenth，这个字段表示类字段的数量，DemoClass有两个字段id和data，所以这里会写入0x0002；</p>
<p>接下来是一个循环，可以看出是遍历字段的：首先获取到一个字段，然后写入一个字节TypeCode，然后使用writeUTF()写入字段名。对于DemoClass两个字段将分别写入：0x0002+bin(&lsquo;id&rsquo;)和0x0004+bin(&lsquo;data&rsquo;)。对于不是基本数据类型的字段，还将写入代表其类型的字符串。</p>
<p>接下来会回到writeNonProxyDesc()方法中：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414182929644.png alt=image-20210414182929644></p>
<p>接下来使用desc创建了一个Class对象cl，并且设置bout的mode为true，这意味两件事：首先bout被设置为了block data模式，这是很明显的；第二点是缓冲区的数据将会被写入到输出流，关于这一点，可以在Debugger中监视bout下的out字段或者在最外层监视bytesOut字段：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414183520936.png alt=image-20210414183520936></p>
<blockquote>
<p>至于Block Data下干了什么暂时还不太理解。</p>
</blockquote>
<p>在最后，又调用了writeClassDesc(desc.getSuperDesc(), false)，递归写入父类的信息，递归最终会到null：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414184333039.png alt=image-20210414184333039></p>
<p>writeNull()方法调用bout.writeByte(TC_NULL)：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414184912562.png alt=image-20210414184912562></p>
<p>所以在对类的描述最终会以一个0x70结束。</p>
<p>这一部分结束，是desc基本结束，也就是说，到此为止写入的都是和类相关的信息。也可已看出来到此为止都还没有写入和对象相关的数据。</p>
<h4 id=writeserialdata>writeSerialData</h4>
<p>接下来向外层返回，会回到writeOrdinaryObject()处：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414185137636.png alt=image-20210414185137636></p>
<p>首先是hanles.assign()方法，这里就会将其写入到handles中，当下一次再对这个对象进行序列化时就会再之前的判断中使用writeHandle()方法；</p>
<p>继续向下，我们这里时使用序列化方法，所以会调用下方的writeSerialData(obj, desc)方法：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414192848900.png alt=image-20210414192848900></p>
<p>虽然内容很长，但是中间的部分暂时不用管，一般情况下会跳到defaultWriteFeilds(obj, slotDesc)。跟踪进去：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414193358451.png alt=image-20210414193358451></p>
<p>还是先创建了一个类，然后做一个简单的检验。</p>
<p>接下来的一部分时获取到所有基本数据类型的值并存入的过程。首先是desc.getPrimDataSize()获取到所有基本数据类型的字段占据的总空间大小，然后为primVals申请相应的空间。获取到空间之后，使用getPrimFieldValues()方法获取到对象所有基本数据类型的变量的值，并保存到primVals中；然后调用bout.write()方法。</p>
<blockquote>
<p>getPrimFieldValues()也是一种反射的应用，通过get(obj)的方法获取到对象的数据。</p>
</blockquote>
<p>这里bout.write()不是写入缓冲区中，可以跟进看一下：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414200206509.png alt=image-20210414200206509></p>
<p>首先判断copy或blkmode是否为flase，blkmode几位Block Mode；这里copy设置为了flase，因此会直接进入其中，然后执行drain()，这个方法的作用将缓冲区的数据写入的输出流中，接下来再执行out.write()方法：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414200507328.png alt=image-20210414200507328></p>
<p>这个方法就是调用向输出流写入b[off]起始的固定长度的数据；因此调用这两个方法后会将数据直接写入到输出流当中。</p>
<p>处理完了基本数据类型的数据，接下来的部分是处理非基本类型的数据，即对象，比如String：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414200917221.png alt=image-20210414200917221></p>
<p>首先是获取到所有的对象类型的字段；然后创建一个对象数组，类似getPrimFieldValues()，这里使用desc.getObjFieldValues(obj, objVals)获取到所有对象并传入到objVals中，然后使用循环对每个字段进行操作，可以看到，对类进行操作时依旧是调用writeObject0()进行处理，也就是递归的处理：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414201542097.png alt=image-20210414201542097></p>
<p>这里对String data操作时会调用这个方法，可以看到这里depth变成了2；<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414201700874.png alt=image-20210414201700874></p>
<p>与之前的不同，这里由于是一个字符串，所以会调用writeString方法：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414201743159.png alt=image-20210414201743159></p>
<p>同样是调用handles.assign()将对象保存到handles，然后获取到长度，开始进行写入，首先写入一个字节的值表示这是个String对象：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414201957026.png alt=image-20210414201957026></p>
<p>然后调用writeUTF()将字符串写入到数据流中。</p>
<p>然后返回到writeObject0()中，结束后depth减一：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414202124175.png alt=image-20210414202124175></p>
<p>到此，对象类型的数据也处理完毕；因此返回到writeObject0()，此时depth恢复0，序列化结束：<img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414202419096.png alt=image-20210414202419096></p>
<h3 id=流程总结>流程总结</h3>
<p><img src=https://causality-blog.oss-cn-hangzhou.aliyuncs.com/hugo/notes/java/serialization/image-20210414202712598.png alt=image-20210414202712598></p>
<ol>
<li>在创建ObjectOutputStream时会向其开头添加两个两字节的常量：STREAM_MAGIC = (short)0xaced 和 STREAM_VERSION = 5</li>
<li>经过各种检查判断是否可以不进行序列化；</li>
<li>对于需要序列化的对象，开始进行序列化；</li>
<li>写入一个字节 TC_OBJECT = (byte)0x73 表示是一个Object对象；</li>
<li>写入一个字节 TC_CLASSDESC = (byte)0x72 表示开始序列化 desc；</li>
<li>接下来两个字节写入描述符长度（0x21），然后写入描述符（b&rsquo;top.causality.learnjava.DemoClass')，之后再写入八个字节的SerialVersionUID；</li>
<li>写入标志位，Serializable 接口会写入 0x02；</li>
<li>然后写入类变量的数量，两个字节（0x0002）；</li>
<li>遍历所有字段，依次写入一个字节的TypeCode（0x49，0x4C）、两个字节的字段长度（0x0002、0x0004）、字段值（b&rsquo;id'、b&rsquo;data'）；</li>
<li>对于不是基本类型的字段，写入代表其类型的字符串（0x0012，b&rsquo;Ljava/lang/String;'）；</li>
<li>可选块数据结束标识 TC_ENDBLOCKDATA = (byte)0x78；</li>
<li>递归调用写入父类描述符，直到父类描述符为null，写入TC_NULL = (byte)0x70；</li>
<li>描述符序列化结束，开始对对象数据进行序列化：</li>
<li>获取所有原始数据类型数据，直接写入到输出流中（0x0001）；</li>
<li>获取所有非基本数据类型的数据，递归的调用写入到数据流中，这里字符串型的依次写入TC_STRING = (byte)0x74、字符串长度（0x000C）、字符串（b&rsquo;aSimpleClass'）。</li>
</ol>
<h3 id=遗留问题>遗留问题</h3>
<ul>
<li>Block Mode是怎样读写的</li>
<li>Slot</li>
<li>各种检验</li>
</ul>
<h3 id=对象反序列化过程跟踪>对象反序列化过程跟踪</h3>
<h3 id=中间类>中间类</h3>
<h4 id=handletable>HandleTable</h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Lightweight identity hash table which maps objects to integer handles,
</span><span style=color:#75715e> * assigned in ascending order.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HandleTable</span> <span style=color:#f92672>{</span>

    <span style=color:#75715e>/* number of mappings in table/next available handle */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* size threshold determining when to expand hash spine */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> threshold<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* factor for computing size threshold */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> loadFactor<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* maps hash value -&gt; candidate handle value */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> spine<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* maps handle value -&gt; next candidate handle value */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> next<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* maps handle value -&gt; associated object */</span>
    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> objs<span style=color:#f92672>;</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Creates new HandleTable with given capacity and load factor.
</span><span style=color:#75715e>     */</span>
    HandleTable<span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>float</span> loadFactor<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>loadFactor</span> <span style=color:#f92672>=</span> loadFactor<span style=color:#f92672>;</span>
        spine <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>];</span>
        next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>];</span>
        objs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>];</span>
        threshold <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>initialCapacity <span style=color:#f92672>*</span> loadFactor<span style=color:#f92672>);</span>
        clear<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Assigns next available handle to given object, and returns handle
</span><span style=color:#75715e>     * value.  Handles are assigned in ascending order starting at 0.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>assign</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>&gt;=</span> next<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            growEntries<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>&gt;=</span> threshold<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            growSpine<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        insert<span style=color:#f92672>(</span>obj<span style=color:#f92672>,</span> size<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> size<span style=color:#f92672>++;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Looks up and returns handle associated with given object, or -1 if
</span><span style=color:#75715e>     * no mapping found.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> hash<span style=color:#f92672>(</span>obj<span style=color:#f92672>)</span> <span style=color:#f92672>%</span> spine<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> spine<span style=color:#f92672>[</span>index<span style=color:#f92672>];</span> i <span style=color:#f92672>&gt;=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>=</span> next<span style=color:#f92672>[</span>i<span style=color:#f92672>])</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>objs<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>return</span> i<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Resets table to its initial (empty) state.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>fill</span><span style=color:#f92672>(</span>spine<span style=color:#f92672>,</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
        Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>fill</span><span style=color:#f92672>(</span>objs<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> size<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
        size <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Returns the number of mappings currently in table.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> size<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Inserts mapping object -&gt; handle mapping into table.  Assumes table
</span><span style=color:#75715e>     * is large enough to accommodate new mapping.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> handle<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> hash<span style=color:#f92672>(</span>obj<span style=color:#f92672>)</span> <span style=color:#f92672>%</span> spine<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
        objs<span style=color:#f92672>[</span>handle<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> obj<span style=color:#f92672>;</span>
        next<span style=color:#f92672>[</span>handle<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> spine<span style=color:#f92672>[</span>index<span style=color:#f92672>];</span>
        spine<span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> handle<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Expands the hash &#34;spine&#34; -- equivalent to increasing the number of
</span><span style=color:#75715e>     * buckets in a conventional hash table.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>growSpine</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        spine <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[(</span>spine<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;&lt;</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>];</span>
        threshold <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>spine<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> loadFactor<span style=color:#f92672>);</span>
        Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>fill</span><span style=color:#f92672>(</span>spine<span style=color:#f92672>,</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> size<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
            insert<span style=color:#f92672>(</span>objs<span style=color:#f92672>[</span>i<span style=color:#f92672>],</span> i<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Increases hash table capacity by lengthening entry arrays.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>growEntries</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> newLength <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>next<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;&lt;</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> newNext <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>newLength<span style=color:#f92672>];</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>arraycopy</span><span style=color:#f92672>(</span>next<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> newNext<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> size<span style=color:#f92672>);</span>
        next <span style=color:#f92672>=</span> newNext<span style=color:#f92672>;</span>

        Object<span style=color:#f92672>[]</span> newObjs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>newLength<span style=color:#f92672>];</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>arraycopy</span><span style=color:#f92672>(</span>objs<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> newObjs<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> size<span style=color:#f92672>);</span>
        objs <span style=color:#f92672>=</span> newObjs<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Returns hash value for given object.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>identityHashCode</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;</span> 0x7FFFFFFF<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>size字段的作用很明显，就是标识hash表的大小；根据下面的方法，每存入一个对象，size值都会加一；通过size与spine和threshold的比较来判断hash表的容量；当容量不够时就会调用相应方法来增加容量。</p>
<p>assign方法会调用insert方法将对象插入到hash表中，然后返回一个handle值（size）。</p>
<p>顾名思义，lookup方法是寻找</p>
<h4 id=replacetable>ReplaceTable</h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Lightweight identity hash table which maps objects to replacement
</span><span style=color:#75715e> * objects.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReplaceTable</span> <span style=color:#f92672>{</span>

    <span style=color:#75715e>/* maps object -&gt; index */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> HandleTable htab<span style=color:#f92672>;</span>
    <span style=color:#75715e>/* maps index -&gt; replacement object */</span>
    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> reps<span style=color:#f92672>;</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Creates new ReplaceTable with given capacity and load factor.
</span><span style=color:#75715e>     */</span>
    ReplaceTable<span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> initialCapacity<span style=color:#f92672>,</span> <span style=color:#66d9ef>float</span> loadFactor<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        htab <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HandleTable<span style=color:#f92672>(</span>initialCapacity<span style=color:#f92672>,</span> loadFactor<span style=color:#f92672>);</span>
        reps <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>];</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Enters mapping from object to replacement object.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>assign</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>,</span> Object rep<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> htab<span style=color:#f92672>.</span><span style=color:#a6e22e>assign</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>index <span style=color:#f92672>&gt;=</span> reps<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            grow<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        reps<span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> rep<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Looks up and returns replacement for given object.  If no
</span><span style=color:#75715e>     * replacement is found, returns the lookup object itself.
</span><span style=color:#75715e>     */</span>
    Object <span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>Object obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> htab<span style=color:#f92672>.</span><span style=color:#a6e22e>lookup</span><span style=color:#f92672>(</span>obj<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>index <span style=color:#f92672>&gt;=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> reps<span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>:</span> obj<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Resets table to its initial (empty) state.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>fill</span><span style=color:#f92672>(</span>reps<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> htab<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>(),</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
        htab<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Returns the number of mappings currently in table.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> htab<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Increases table capacity.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grow</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Object<span style=color:#f92672>[]</span> newReps <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[(</span>reps<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>&lt;&lt;</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>];</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>arraycopy</span><span style=color:#f92672>(</span>reps<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> newReps<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> reps<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>);</span>
        reps <span style=color:#f92672>=</span> newReps<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可以看出，这个表只有两个字段htab和reps。其中htab是一个HandleTable类型的变量，也就是说其中存储这一个hash表；reps则是一个对象数组。根据注释可以知道，htab的目的是通过对象来获取到一个index，而reps则是根据这个index获取到可替换的对象。</p>
<p>接下来时assign方法，也就是说通过这个方法来设置可替换对象。这个assign会调用htab的assign方法，也就是会将obj存入到htab中，并且获得返回的handle值（index）；然后设置reps[index]的值为替换对象。</p>
<p>lookup方法自然是寻找可替换对象，该方法首先在htab中寻找是否有该对象，如果有则会获取到hanlde值（index），然后使用这个值从reps中获取到替换对象。</p>
</div>
</div>
<div class=w-200>
<div id=gitalk></div>
<script>var gitalk=new Gitalk({clientID:'9a04c6b451fbce76511d',clientSecret:'430c540c77ecd6b59749c60f0341c057bd5320a0',repo:'Causa1ity.github.io',owner:'Causa1ity',admin:'Causa1ity',id:'/devops/java/serialization/',distractionFreeMode:!1});gitalk.render('gitalk')</script>
</div>
</div>
</div>
<script>CodeLine.initOnPageLoad({copyBtn:{show:!0,position:'top'},toggleBtn:{show:!1}})</script>
<div class="text-center my-8">
<span class="font-serif text-lg">
Powered By <a href=https://gohugo.io/ class="font-bold hover:text-blue-400">Hugo</a>
with theme <a href=https://github.com/causa1ity/hugo-theme-noth/ class="font-bold hover:text-blue-400">Noth</a>
</span>
</div></body>
</html>