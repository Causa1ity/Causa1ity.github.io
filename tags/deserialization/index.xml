<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Deserialization on Forgotten Land</title><link>https://causality.top/tags/deserialization/</link><description>Recent content in Deserialization on Forgotten Land</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 27 Sep 2021 23:05:34 +0800</lastBuildDate><atom:link href="https://causality.top/tags/deserialization/index.xml" rel="self" type="application/rss+xml"/><item><title>Java序列化(ObjectOutputStream)过程分析</title><link>https://causality.top/security/java/java%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 27 Sep 2021 23:05:34 +0800</pubDate><guid>https://causality.top/security/java/java%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>对Java利用ObjectOutputStream对对象进行序列化操作的流程进行了学习，记录下对对象序列化的过程，最后按照对象类型分类总结出了序列化后的字节序列的含义。 构造函数和writeObject</description></item><item><title>CommonsCollections3-7 利用连分析</title><link>https://causality.top/security/java/commonscollections3-7/</link><pubDate>Sat, 25 Sep 2021 17:06:23 +0800</pubDate><guid>https://causality.top/security/java/commonscollections3-7/</guid><description>理解了CC1和CC2之后，CC3-7其实十分简单，CC3和CC1类似，但是换了一种命令执行的方式，CC4也是这样；而CC5-7则是寻找到了另外触发LazyMap.get的方式，在这个前提下，就只需要关</description></item><item><title>CommonsCollections2 利用链分析</title><link>https://causality.top/security/java/commonscollections2/</link><pubDate>Sat, 25 Sep 2021 16:35:53 +0800</pubDate><guid>https://causality.top/security/java/commonscollections2/</guid><description>Gadget Chain /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 这个链分成两部分，前半部分为触发TransformingComparator.compare() ，后半部分则是通过其构造一个命令执行。 TransformingComparat</description></item><item><title>CommonsCollections1 利用链分析</title><link>https://causality.top/security/java/commonscollections1/</link><pubDate>Tue, 21 Sep 2021 23:28:15 +0800</pubDate><guid>https://causality.top/security/java/commonscollections1/</guid><description>Gadget Chain Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections 这条利用链其实可以分为两个部分，后半部分从ChainedTransformer之后目的是为了构造一个可序列化的命令执行，前半部分则是用来触发这个操作的调用链</description></item><item><title>Java 反序列化漏洞</title><link>https://causality.top/security/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</link><pubDate>Tue, 13 Apr 2021 20:01:18 +0800</pubDate><guid>https://causality.top/security/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</guid><description>初窥 Before 在理解Java反序列化漏洞之前，首先需要了解Java序列化与反序列化、Java反射的基本概念： Java 序列化 Java 反射 简单来说，Java 序列化是指将 Java 对象转换成一个字节数组的过程；反序列化则是将一个字节数</description></item></channel></rss>